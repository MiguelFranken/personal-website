---
title: 'Carbon'
description: "Carbon is a decentralized generative art project where the rarity of the unique digital collectibles (NFTs) is determined by how someone's wallet balance at the time of minting compares with the wallet balance of previous minters at the time they minted their token. For that, the balance of each minter is stored on-chain in an Order Statistics Tree and is used to calculate the rank, i.e., its index in a sorted list of all balances."
image: '/carbon/banner.png'
---

# Overview

Carbon is a decentralized generative art project where the rarity of the unique digital collectibles ([ERC721 NFTs](https://ethereum.org/en/developers/docs/standards/tokens/erc-721/#top)) is determined by how someone's wallet balance at the time of minting compares
with the wallet balance of previous minters at the time they minted their token.

Carbon tokens are fair-priced meaning that the cost for minting will always be 1% of that minter's wallet balance and is primarily decisive for the rarity of the minted NFT.
The total supply of NFTs is limited to 10000 unique tokens and each image is stored decentralized on [IPFS](https://ipfs.io) and [Filecoin](https://filecoin.io) forever.

---

# In a Nutshell

- Decentralized generative art project living on Ethereum chain
- Unique digital collectibles ([ERC721 NFTs](https://eips.ethereum.org/EIPS/eip-721))
- All about digital diamond image collectibles in different sizes!
- 10 different diamond sizes and special diamonds for minters having the largest wallet balance at the time of minting
- Diamond size is determined how someone's wallet balance at the time of minting compares with the wallet balance of previous minters at the time they minted their token
- Limited to 10000 unique tokens
- Images and metadata stored on [IPFS](https://github.com/cryptococks-xyz/cryptococks-contract#ipfs) and [Filecoin](https://filecoin.io) forever.
- Integrated into [OpenSea marketplace collection](https://opensea.io/collection/todo)
- Smart contract is verified & publicly available on [Etherscan](#) and [GitHub](#)

---

# Project Status

The project is still in development. The contract has been deployed on a Ethereum test chain. Website minting functionality works, but more tests has to be done before going live on a Ethereum mainnet.

---

# Ethereum Contract

When minting a Carbon token, we store on-chain your balance
(or more specifically, the fee of 1% of your wallet balance) in an
[Order Statistics Tree](https://en.wikipedia.org/wiki/Order_statistic_tree) in order to be able to efficiently find the rank of this balance, i.e. its index in a sorted list of balances of all minters.
We calculate the [Percentile Rank (PR)](https://en.wikipedia.org/wiki/Percentile_rank), i.e., the percentage of
balances in its frequency distribution that are less than the minter's current wallet balance.
We bin the continuous PRs (e.g. 33% or 99%) uniformly into 10 intervals such that
all bins have nearly identical widths. We map these 10 intervals (decentiles) to the 10 possible diamond sizes, so that PRs in [0,10) are mapped to diamond size 1, PRs in [20,30) are mapped to diamond size 2, ..., PRs in [90,100) are mapped to diamond size 10. Only the largest balance at the point in time of the mint will receive a special length, namely 11, which persists this information on the blockchain (i.e., see token URI and linked metadata fields).

In other words, this means that someone's diamond will be as small as possible (length 1 of 10) if that minter's balance at the time of minting is no greater or equal to 10% of all the balances of the previous minters. 90% of previous minters have made a larger investment to obtain a Carbon NFT.

---

# Sustainability

Storing and verifying your diamond size on-chain consumes a lot of energy, therefore 30% of all primary market sales will be donated to the [Trees for the Future](https://trees.org/) reforestation project via the crypto charity [The Giving Block](https://thegivingblock.com/donate/trees-for-the-future/).

The revenue is donated in bundles at regular intervals and this process is defined in the ethereum contract itself so that the donating is automated. Even the creators of the project will not be able to change or disable this after the deployment of the contract. This makes the whole system very secure!

---

# Kubernetes Cluster Tutorial

## Prerequisites
- Virtual Machine
  - For example from [DigitalOcean](https://www.digitalocean.com/products/droplets)
- Domain name and the ability to create DNS records in that domain.
  - [Google Domains](https://domains.google/), [NameCheap](https://www.namecheap.com/) and [GoDaddy](https://www.godaddy.com/) are well known registrars.
- Software
  - [kubectl](https://kubernetes.io/docs/tasks/tools/#kubectl): The Kubernetes command-line tool which allows you to configure Kubernetes clusters
  - [curl](https://everything.curl.dev/get): A command-line tool for connecting to a web server using HTTP and HTTPS.

## Install MicroK8s

First, connect to your virtual machine via SSH:
```shell
ssh root@<IP_OF_VIRTUAL_MACHINE>
```

We decided to install [MicroK8s](https://microk8s.io/), which is a minimal, lightweight Kubernetes you can run and use on practically any machine. It can be installed with a snap:

```shell
# Install
sudo snap install microk8s --classic --channel=1.24

# Verify Installation
microk8s status --wait-ready
```

## Access Remote Cluster

To access a cluster, you need to know the location (i.e., the IP address of our virtual machine) of the cluster and have credentials to access it.

```shell
# From the virtual machine
sudo microk8s kubectl config view --raw > $HOME/.kube/config

# Copy the ~/.kube/config from the virtual machine to your local machine
scp root@<IP_OF_VIRTUAL_MACHINE>:~/.kube/config ~/.kube/config

# Open an SSH tunnel (everytime you need to use kubectl on the local machine to access remote cluster)
ssh -N -L localhost:16443:localhost:16443 root@<IP_OF_VIRTUAL_MACHINE>
```

> If you have already configured other Kubernetes clusters, you should merge the output from the microk8s config with the existing config (copy the output, omitting the first two lines, and paste it onto the end of the existing config using a text editor). See [here](https://kubernetes.io/docs/tasks/access-application-cluster/configure-access-multiple-clusters/) for more information.

## Create Secrets
```
# On your machine
kubectl create secret generic cc-secrets --from-literal=mysql_password=<INSERT_MYSQL_PASSWORD>
```

### Fetching Containers From Private Repositories

We use GitHub packages to store our built API Docker container images alongside the project's code and allow private access to the published packages.
Our Kubernetes cluster obtains the Docker API image from the private GitHub package registry, which requires setting up a personal access token that allows access to our published package. [The GitHub documentation describes how to create a PTA](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token). Make sure that you grant your token `read:packages` permissions, which allows the token holder to download packages from GitHub Package Registry.

If you want to fetch container images from a private repository from your Kubernetes cluster, you need a way for the kubelet on each node to authenticate to that repository. You can configure image pull secrets to make this possible.

```shell
echo -n <your-github-username>:<PAT> | base64
# outputs <BASE_64_ENCODED_PAT>
```

Insert `<BASE_64_ENCODED_PAT>` into `regcred.yml` and then apply the manifest by `kubectl apply -f regcred.yml`.

## API, Database & Redis Manifests
```shell
# On your machine
kubectl apply -f api.yaml
kubectl apply -f db.yaml
kubectl apply -f redis.yaml
```

## Manage TLS Certification
We use [cert-manager](https://cert-manager.io/) in our cluster to generate and manage signed TLS certificates from [Let's Encrypt](https://letsencrypt.org/getting-started/), using an [HTTP-01 challenge](https://letsencrypt.org/docs/challenge-types/#http-01-challenge).

We need to do is install [cert-manager](https://cert-manager.io/), and we'll install it the easy using [kubectl](https://kubernetes.io/docs/tasks/tools/#kubectl).
This will create three Deployments, and a bunch of Services and Pods in a new namespace called `cert-manager`.

```shell
# Install cert-manager resources from official YAML manifest file on GitHub
kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.9.1/cert-manager.yaml

# To verify the installation, run the following command
kubectl get pods --namespace cert-manager

# An Issuer is a custom resource which tells cert-manager how to sign a Certificate.
# Let's Encrypt uses the Automatic Certificate Management Environment (ACME) protocol which is why the configuration below is under a key called `acme`.
# The email address is only used by Let's Encrypt to remind you to renew the certificate after 30 days before expiry. You will only receive this email if something goes wrong when renewing the certificate with cert-manager.
kubectl apply -f clusterissuer.yaml

# You can check the status of the issuer
kubectl describe issuers.cert-manager.io letsencrypt-prod
```

## Manage External Cluster Access

The API is running at this point already inside the Kubernetes cluster but there is no route or proxy through which Internet clients can connect to it, yet! So you won't be able to reach the API yet. Now we will create a Kubernetes Ingress object and this will trigger the creation of a various services which together allow Internet clients to reach the API running inside the Kubernetes cluster.

Enable Ingress Addon:
```shell
# from the virtual machine
microk8s.enable dns
microk8s.enable ingress
```

```shell
# from the local machine
kubectl apply -f ingress.yml
```

You can test the deployment via:
```shell
curl -v https://<YOUR_DOMAIN>/token/count
```
